#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>
#include <errno.h>
#include <omp.h>

#define W 272
#define D 3
#define HASH_SEED 1934

#define TOTAL_FILES 3981
#define FILES_PER_SKETCH 150
#define TOTAL_SKETCHES 10000

unsigned int hash(const char *str, int seed) {
    unsigned long hash = seed;
    int c;
    while ((c = *str++))
        hash = ((hash << 5) + hash) + c;
    return hash % W;
}

typedef struct {
    int table[D][W];
} CountMinSketch;

void initCMS(CountMinSketch *cms) {
    for (int i = 0; i < D; i++) {
        for (int j = 0; j < W; j++) {
            cms->table[i][j] = 0;
        }
    }
}

void updateCMS(CountMinSketch *cms, const char *item) {
    for (int i = 0; i < D; i++) {
        int index = hash(item, HASH_SEED + i);
        cms->table[i][index]++;
    }
}

int queryCMS(CountMinSketch *cms, const char *item) {
    int minCount = cms->table[0][hash(item, HASH_SEED)];
    for (int i = 1; i < D; i++) {
        int index = hash(item, HASH_SEED + i);
        if (cms->table[i][index] < minCount) {
            minCount = cms->table[i][index];
        }
    }
    return minCount;
}

void printCMS(CountMinSketch *cms) {
    printf("Count-Min Sketch Table:\n");
    for (int i = 0; i < D; i++) {
        for (int j = 0; j < W; j++) {
            printf("%d ", cms->table[i][j]);
        }
        printf("\n");
    }
}

void saveCMSToCSV(CountMinSketch *cms, const char *filename) {
    char directory[256];
    strcpy(directory, filename);
    char *last_slash = strrchr(directory, '/');
    if (last_slash != NULL) {
        *last_slash = '\0';
        struct stat st = {0};
        if (stat(directory, &st) == -1) {
            if (mkdir(directory, 0700) != 0 && errno != EEXIST) {
                perror("mkdir");
                return;
            }
        }
    }

    FILE *file = fopen(filename, "w");
    if (file == NULL) {
        perror("fopen");
        return;
    }

    for (int i = 0; i < D; i++) {
        for (int j = 0; j < W; j++) {
            fprintf(file, "%d", cms->table[i][j]);
            if (j < W - 1) {
                fprintf(file, ",");
            }
        }
        fprintf(file, "\n");
    }

    fclose(file);
}

void processCSVFiles(CountMinSketch *cms, char *files[], int num_files) {
    for (int i = 0; i < num_files; i++) {
        FILE *file = fopen(files[i], "r");
        if (file == NULL) {
            perror("fopen");
            continue;
        }

        char line[1024];
        while (fgets(line, sizeof(line), file)) {
            char *system_call = strtok(line, "\n");
            if (system_call != NULL) {
                updateCMS(cms, system_call);
            }
        }
        fclose(file);
    }
}

void generateRandomFiles(char *files[], int num_files, char *new_files[], int new_total, char *other_files[], int other_total) {
    int selected[new_total];
    memset(selected, 0, sizeof(selected));

    // Benign: 149
    for (int i = 0; i < num_files - 1; i++) {
        int index;
        do {
            index = rand() % new_total;
        } while (selected[index]);
        selected[index] = 1;
        files[i] = new_files[index];
    }

    // Malware: 1
    int index = rand() % other_total;
    files[num_files - 1] = other_files[index];
}

void collectAllFiles(const char *directory, char *all_files[], int *total_files) {
    struct dirent *entry;
    DIR *dp = opendir(directory);

    if (dp == NULL) {
        perror("opendir");
        return;
    }

    int index = 0;
    while ((entry = readdir(dp))) {
        if (entry->d_type == DT_REG) {
            all_files[index] = malloc(strlen(directory) + strlen(entry->d_name) + 2);
            if (all_files[index] == NULL) {
                perror("malloc");
                closedir(dp);
                return;
            }
            snprintf(all_files[index], 256, "%s/%s", directory, entry->d_name);
            index++;
        }
    }
    *total_files = index;

    closedir(dp);
}

int main() {
    srand(time(NULL));

    char *new_files[TOTAL_FILES];
    int new_total_files = 0;
    collectAllFiles("./dataset/new_0", new_files, &new_total_files);

    char *other_files[TOTAL_FILES];
    int other_total_files = 0;
    collectAllFiles("./dataset/1", other_files, &other_total_files);

    #pragma omp parallel for schedule(dynamic) num_threads(36)
    for (int i = 0; i < TOTAL_SKETCHES; i++) {
        CountMinSketch cms;
        initCMS(&cms);

        char *selected_files[FILES_PER_SKETCH];
        generateRandomFiles(selected_files, FILES_PER_SKETCH, new_files, new_total_files, other_files, other_total_files);

        processCSVFiles(&cms, selected_files, FILES_PER_SKETCH);

        char filename[256];
        snprintf(filename, sizeof(filename), "./dataset/cms_1/cms_%04d.csv", i);
        saveCMSToCSV(&cms, filename);
        
        #pragma omp critical
        printf("%05d/10000 completed\n", i);
    }

    for (int i = 0; i < new_total_files; i++) {
        free(new_files[i]);
    }
    for (int i = 0; i < other_total_files; i++) {
        free(other_files[i]);
    }

    return 0;
}

